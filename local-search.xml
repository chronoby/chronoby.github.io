<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Precomputed Radiance Transfer</title>
    <link href="/2021/08/23/prt/"/>
    <url>/2021/08/23/prt/</url>
    
    <content type="html"><![CDATA[<h1 id="Precomputed-Radiance-Transfer"><a href="#Precomputed-Radiance-Transfer" class="headerlink" title="Precomputed Radiance Transfer"></a>Precomputed Radiance Transfer</h1><p>尽管渲染方程十分优雅、简洁，但直接求解是不切实际的，因为积分域包含了无穷的方向。Precomputed Radiance Transfer(PRT)是一个计算实时全局光照的尝试，他把问题分成了两部分，一部分在预计算步骤解决，另一部分实时计算。通过一些简化和近似，PRT 等式可以直接从渲染方程推导出来。</p><span id="more"></span><h2 id="PTR"><a href="#PTR" class="headerlink" title="PTR"></a>PTR</h2><p>PRT 有两个主要的假设：</p><ul><li>场景中的所有物体不是发光体</li><li>光源是无穷远的(使入射光独立于入射点的位置)</li></ul><script type="math/tex; mode=display">L_o(p,\omega_o) = \int_{\Omega^+} L_i(p,\omega_i)\rho(p,\omega_i,\omega_o)V(p)max(0,n \cdot\omega_i)\mathrm{d}\omega_i</script><p>另一个 PRT 的假设是仅考虑漫反射(disfuse/Lambertian reflectance)，这种情况下，$\rho$ 是反射系数/Pi(常数)。我们可以将原方程写为</p><script type="math/tex; mode=display">L_o(p,\omega_o) = \rho \int_{\Omega^+} L_i(p,\omega_i) T(p, \omega_o, \omega_i)\mathrm{d}\omega_i</script><p>可见，传输部分和光照部分是相互独立的，可以分开计算。而 T 可以预计算。</p><h2 id="基函数"><a href="#基函数" class="headerlink" title="基函数"></a>基函数</h2><p>给定一个函数$f(x)$，基函数 $\beta$ 是一个用来投影和重构的函数的无限集。函数 &amp;f&amp; 到任何函数 $\beta$ 的投影用 $c_i$ 来衡量</p><script type="math/tex; mode=display">c_i = \int f(x)\beta_i(x)\mathrm{d}x</script><p>原函数 $f$ 可以写为</p><script type="math/tex; mode=display">f(x) = \lim\limits_{n\to\infty}\sum\limits_{i=1}^{n}c_i\beta_i(x)</script><p>只取有限个(n个)项</p><script type="math/tex; mode=display">f(x) = \sum\limits_{i=1}^{n}c_i\beta_i(x)</script><p>对于 PRT，我们使用正交的基函数，即任意两个不同基函数的积分为 0。同时提供了一个非常好的性质：</p><script type="math/tex; mode=display">c_k = \int f(x)\beta_k(x)\mathrm{d}x\\d_k = \int g(x)\beta_k(x)\mathrm{d}x\\\int f(x)g(x)\mathrm{d}x=\int \sum\limits_{k=1}^{n}c_k\beta_k(x) \sum\limits_{k=1}^{n}d_k\beta_k(x)\mathrm{d}x\\=\sum\limits_{k=1}^{n}c_kd_k\int\beta_k(x)\beta_k(x)\mathrm{d}x\\=\sum\limits_{k=1}^{n}c_kd_k</script><p>在 PRT 中，我们使用的正交基函数为 Spherical Harmonics(球面谐波函数)</p><p>这提供了一个有用的机制去分解渲染方程：</p><ol><li>将 $L$ 和 $T$ 投影到正交基(预处理阶段完成)</li><li>将积分近似为点积(运行时进行计算)</li></ol>]]></content>
    
    
    <categories>
      
      <category>Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rendering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>辐射度量学、BRDF 和渲染方程</title>
    <link href="/2021/05/26/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6-BRDF-%E5%92%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/"/>
    <url>/2021/05/26/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6-BRDF-%E5%92%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>辐射度量学</strong>是衡量电磁辐射强弱的学科，在渲染领域具有极大意义。在一些基本概念的基础上，我们引入了一个四维函数 BRDF，用来描述一个方向上的入射光线在每个出射方向上反射了多少能量。最后得出大名鼎鼎的 Rendering Equation(渲染方程)。</p><span id="more"></span><h2 id="辐射度量学主要概念"><a href="#辐射度量学主要概念" class="headerlink" title="辐射度量学主要概念"></a>辐射度量学主要概念</h2><h3 id="Radiant-Energy"><a href="#Radiant-Energy" class="headerlink" title="Radiant Energy"></a>Radiant Energy</h3><ul><li><strong>Radiant Energy</strong> (辐射能) Q: 电磁辐射的能量</li></ul><script type="math/tex; mode=display">Q[J=Joule]</script><h3 id="radiant-flux-power"><a href="#radiant-flux-power" class="headerlink" title="radiant flux (power)"></a>radiant flux (power)</h3><ul><li><strong>radiant flux</strong> (辐射通量) or <strong>radiant power</strong> (辐射功率) is the radiant energy emitted, reflected, transmitted or received, per unit time</li></ul><script type="math/tex; mode=display">\Phi \equiv \frac{\mathrm{d}Q}{\mathrm{d}t}[W=Watt][lm=lumen]^*</script><h3 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h3><ul><li>Radiant Intensity (辐射强度): the radiant flux emitted, reflected, transmitted or received, per unit solid angle</li></ul><script type="math/tex; mode=display">I \equiv \frac{\mathrm{d}\Phi}{\mathrm{d}\Omega}[W/sr][lm/sr=cd=candela]^*</script><h3 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h3><p>Irradiance(辐照度): the radiant flux (power) received by a surface per unit area</p><script type="math/tex; mode=display">E(x) \equiv \frac{\mathrm{d}\Phi(x)}{\mathrm{d}A}[W/m^2][lm/m^2=lux]^*</script><h3 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h3><p>Radiance(辐射度): the radiant flux emitted, reflected, transmitted or received by a given surface, per unit solid angle per unit projected area</p><script type="math/tex; mode=display">L(p,\omega) \equiv \frac{\mathrm{d^2}\Phi(p, \omega)}{\mathrm{d}\omega\mathrm{d}A\cos\theta}[W/(sr \cdot m^2)][cd/m^2=nit]^*</script><h2 id="Fresnel-Term"><a href="#Fresnel-Term" class="headerlink" title="Fresnel Term"></a>Fresnel Term</h2><ul><li>菲涅尔项描述了有多少光被反射和折射</li><li>可以用 Schlick’s approximation 来简化计算</li></ul><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p>Bidirectional Reflectance Distribution Function(BRDF) 描述了入射光线在每个出射方向上反射了多少能量，具体定义为：材质表面某一点上出射辐射度（Radiance）和入射辐照度（Irradiance）的比值</p><script type="math/tex; mode=display">f_r(\omega_i \rightarrow \omega_r) = \frac{\mathrm{d}L_r(\omega_r)}{\mathrm{d}E_i(\omega_i)}= \frac{\mathrm{d}L_r(\omega_r)}{L_i(\omega_i)\cos\theta_i\mathrm{d}\omega_i}[l/sr]</script><h2 id="The-Reflection-Equation"><a href="#The-Reflection-Equation" class="headerlink" title="The Reflection Equation"></a>The Reflection Equation</h2><script type="math/tex; mode=display">L_r(p,\omega_r) = \int_{H^2} f_r(p,\omega_i \rightarrow \omega_r) L_i(p,\omega_i)\cos\theta_i\mathrm{d}\omega_i</script><h2 id="The-Rendering-Equation"><a href="#The-Rendering-Equation" class="headerlink" title="The Rendering Equation"></a>The Rendering Equation</h2><script type="math/tex; mode=display">L_o(p,\omega_o) = L_e(p,\omega_o) + \int_{\Omega^+} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i)(n \cdot\omega_i)\mathrm{d}\omega_i</script>]]></content>
    
    
    <categories>
      
      <category>Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rendering</tag>
      
      <tag>BRDF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compiler-Controlled Prefetching</title>
    <link href="/2020/12/30/Compiler-Controlled-Prefetching/"/>
    <url>/2020/12/30/Compiler-Controlled-Prefetching/</url>
    
    <content type="html"><![CDATA[<h2 id="background">Background</h2><ul><li>it is not uncommon for scientific and other data-intensive programs to spend more than half their run times stalled on memory requests.</li><li>The large, dense matrix operations that form the basis of many such applications typically exhibit little data reuse and high cache miss rate.</li><li>Many of cache misses can be avoided if we augment the demand fetch policy of the cache with a data prefetch operation.</li></ul><span id="more"></span><h2 id="cache-prefetching">Cache prefetching</h2><p>Cache prefetching: Fetching instructions or data from their original storage in slower memory to a faster local memory before it is actually needed</p><ul><li>Hardware based prefetching </li><li>Compiler-Controlled Prefetching<ul><li>Controlled by the compiler</li><li>Analyze the code and insert additional "prefetch" instructions in the program during compilation itself.</li></ul></li></ul><p>The advantage is it hides the data access latency by decoupling and overlaping data transfers and computation and reduces the cache miss Rate</p><h3 id="design-issue">Design Issue</h3><p>A data prefetching strategy has to consider various issues:</p><ul><li>What to prefetch</li><li>When to prefetch</li><li>Cache pollution</li><li>Overhead</li><li>Memory bandwidth</li><li>...</li></ul><h2 id="compiler-controlled-prefetching">Compiler-Controlled Prefetching</h2><p>The task of choosing where in the program to place a fetch instruction relative to the matching load or store instruction is known as prefetch scheduling.</p><p>Whether hand-coded or automated by a compiler, prefetching is most often used within loops responsible for large array calculations.</p><h3 id="loop-based-prefetching">Loop-based prefetching</h3><p>Without prefetching</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;  </span><br><span class="line">    sum += a[i] * b[i];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>With prefetching</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;  </span><br><span class="line">    fetch( &amp;a[i+<span class="number">1</span>] );  </span><br><span class="line">    fetch( &amp;b[i+<span class="number">1</span>] );  </span><br><span class="line">    sum += a[i] * b[i];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="limitation">Limitation</h3><ul><li>Prefetching is normally restricted to loops containing array accesses whose indices are linear functions of the loop indices. Such loops are far less common in general applications.</li><li>Attempts at establishing similar software prefetching strategies for general applications are hampered by their irregular referencing patterns.</li><li>Explicit fetch instructions exacts a performance penalty must be considered.</li><li>Because software prefetching is done statically, it is unable to detect when a prefetched block has been prematurely evicted and needs to be refetched.</li></ul><h2 id="compiler-controlled-prefetching-in-gcc">Compiler-Controlled Prefetching in GCC</h2><h3 id="existing-data-prefetch-support-in-gcc">Existing data prefetch support in GCC</h3><ul><li>A generic prefetch RTL pattern.</li><li>Target-specific support for several targets.</li><li>A __builtin_prefetch function that does nothing on targets that do not support prefetch or for which prefetch support has not yet been added to GCC.</li><li>An optimization enabled by -fprefetch-loop-arrays that prefetches arrays used in loops.</li></ul><h3 id="fprefetch-loop-arrays-optimization">fprefetch-loop-arrays Optimization</h3><p>Procedure:</p><ul><li>Gather all memory references in the single loop.</li><li>For each of the references it decides when it is profitable to prefetch it. To do it, we evaluate the reuse among the accesses, and determines two values: PREFETCH_BEFORE and PREFETCH_MOD</li><li>Determine how much ahead we need to prefetch.</li><li>Determine which of the references we prefetch.</li><li>We unroll and peel loops so that we are able to satisfy PREFETCH_MOD and PREFETCH_BEFORE requirements.</li><li>Emit the prefetch instructions.</li></ul><p>Be careful!</p><p>This option may generate better or worse code; results are highly dependent on the structure of loops within the source code.</p><h3 id="builtin_prefetch-function">__builtin_prefetch( ) function</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __builtin_prefetch (<span class="keyword">const</span> <span class="keyword">void</span> *addr, ...)</span><br></pre></td></tr></table></figure><p>addr: the address of the memory to prefetch.</p><p>There are two optional arguments, rw and locality. - rw: the prefetch is preparing for read or write - locality: degree of temporal locality</p><h4 id="test-for-__builtin_prefetch">Test for __builtin_prefetch( )</h4><p>Test code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> number_of_elements, <span class="keyword">int</span> key)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = number_of_elements<span class="number">-1</span>, mid;  </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;  </span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;  </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> DO_PREFETCH</span></span><br><span class="line">        __builtin_prefetch (&amp;<span class="built_in">array</span>[(mid + <span class="number">1</span> + high)/<span class="number">2</span>], <span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line">        __builtin_prefetch (&amp;<span class="built_in">array</span>[(low + mid - <span class="number">1</span>)/<span class="number">2</span>], <span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">array</span>[mid] &lt; key)  </span><br><span class="line">               low = mid + <span class="number">1</span>;   </span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[mid] == key)  </span><br><span class="line">               <span class="keyword">return</span> mid;  </span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[mid] &gt; key)  </span><br><span class="line">               high = mid<span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test result:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ gcc binarysearch.c -DO_PREFETCH -o with_prefetch -std=c11 -O3  </span><br><span class="line">$ gcc binarysearch.c -o without_prefetch -std=c11 -O3  </span><br><span class="line">  </span><br><span class="line">$ perf <span class="built_in">stat</span> -e L1-dcache-load-misses,L1-dcache-loads ./with_prefetch</span><br><span class="line"> </span><br><span class="line">Performance counter stats <span class="keyword">for</span> <span class="string">&#x27;./with_prefetch&#x27;</span>:  </span><br><span class="line">  </span><br><span class="line">   642,164,744      L1-dcache-load-misses     <span class="comment">#   43.39% of all L1-dcache hits    </span></span><br><span class="line"> 1,384,348,079      L1-dcache-loads                                               </span><br><span class="line">  </span><br><span class="line">   9.888150865 seconds time elapsed</span><br><span class="line"></span><br><span class="line">$ perf <span class="built_in">stat</span> -e L1-dcache-load-misses,L1-dcache-loads ./without_prefetch</span><br><span class="line"></span><br><span class="line">Performance counter stats <span class="keyword">for</span> <span class="string">&#x27;./without_prefetch&#x27;</span>:  </span><br><span class="line">  </span><br><span class="line">   507,426,550      L1-dcache-load-misses     <span class="comment">#   55.35% of all L1-dcache hits    </span></span><br><span class="line">   916,794,127      L1-dcache-loads                                               </span><br><span class="line">  </span><br><span class="line">  14.362018905 seconds time elapsed</span><br></pre></td></tr></table></figure><p>Comments:</p><ul><li>With proper structure of loops of source code, hand-coded prefetching can be effective. For example, in this case, the performance increases about 30%.</li><li>The cache loads increases about 50%, which means we have loaded a lot of junk into the caches and this may put more pressure on other parts of the application.</li><li>A kind of trade off between cache resources and running time.</li></ul><h2 id="conclusion">Conclusion</h2><ul><li>With some particular structure of loops, whether hand-coded or automated by a compiler prefetching can be effective.</li><li>Prefetching technology can only apply to particular structure of loops.</li><li>Be careful to use software prefetching. Be sure to know exactly what you are doing and do sufficient test.</li></ul><h2 id="reference">Reference</h2><ul><li>Vanderwiel S P , Lilja D J . Data prefetch mechanisms[J]. Acm Computing Surveys, 2000, 32(2):174-199. DONG Yushan, LI Chunjiang, XU Ying. Implementation and effects of loop-array-prefetching optimization in GCC. Computer Engineering and Applications, 2016, 52（6）：19-25.</li><li>GCC document: Data Prefetch Support, https://gcc.gnu.org/projects/prefetch.html</li><li>A Taxonomy of Data Prefetching Mechanisms Surendra Byna Yong Chen Xian-He Sun Department of Computer Science Illinois Institute of Technology, Chicago, IL 60616, USA</li><li>Wikipedia: Cache prefetching, https://en.wikipedia.org/wiki/Cache_prefetching</li></ul>]]></content>
    
    
    <categories>
      
      <category>Compiler</category>
      
      <category>Cache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compiler</tag>
      
      <tag>Optimization</tag>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello GoogleTest</title>
    <link href="/2020/12/04/Hello_GoogleTest/"/>
    <url>/2020/12/04/Hello_GoogleTest/</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>GoogleTest 是一个跨平台的 C++ 测试框架，支持各种平台上不同类型的测试。被 Chromium, LLVM 和 OpenCV 等项目所使用。</p><p>If you write C++ code, googletest can help you!</p><span id="more"></span><h2 id="环境">环境</h2><ul><li>OS: Ubuntu 20.10</li><li>CMake: 3.16.3</li><li>GoogleTest: 1.10.0</li></ul><h2 id="构建-googletest">构建 GoogleTest</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/googletest.git -b release-1.10.0</span><br><span class="line"><span class="built_in">cd</span> googletest</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="demo">Demo</h2><p>我们来体验一下</p><p>bubblesort.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>bubblesort.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bubblesort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = data[i];</span><br><span class="line">    data[i] = data[j];</span><br><span class="line">    data[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[j] &gt; data[j + <span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(data, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bubblesort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">bubblesort</span>(a, a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bubblesort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test, case1)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">bubblesort</span>(a, a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(bubble-sort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(GTest REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;GTEST_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(sort bubblesort.cpp main.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(unit_test <span class="keyword">test</span>.cpp bubblesort.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( unit_test</span><br><span class="line">        <span class="variable">$&#123;GTEST_BOTH_LIBRARIES&#125;</span></span><br><span class="line">        pthread )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_test</span>(<span class="keyword">test</span> unit_test)</span><br></pre></td></tr></table></figure><h2 id="运行">运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><code>make test</code>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Running tests...</span><br><span class="line">Test project /home/chronoby/Development/GoogleTest/hello/build</span><br><span class="line">    Start 1: test</span><br><span class="line">1/1 Test #1: test .............................   Passed    0.00 sec</span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 1</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.00 sec</span><br></pre></td></tr></table></figure><p><code>./unit_test</code> 结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[==========] Running 1 test from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 1 test from test</span><br><span class="line">[ RUN      ] test.case1</span><br><span class="line">[       OK ] test.case1 (0 ms)</span><br><span class="line">[----------] 1 test from test (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 1 test from 1 test suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 1 test.</span><br></pre></td></tr></table></figure><p>Hello, GoogleTest!</p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Allocator</title>
    <link href="/2020/10/20/Allocator/"/>
    <url>/2020/10/20/Allocator/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从STL运用角度而言，空间配置器是最不需要介绍的东西，它隐藏在一切组件背后。但若以STL实现角度而言，第一个需要介绍的就是空间配置去，因为整个STL的操作对象都存放在容器之内，而容器一定需要配置空间。</p><span id="more"></span><p>以下介绍的是SGI STL提供的配置器</p><h3 id="C-内存配置和释放操作"><a href="#C-内存配置和释放操作" class="headerlink" title="C++内存配置和释放操作"></a>C++内存配置和释放操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span>...&#125;;<br>Foo * pf = <span class="hljs-keyword">new</span> Foo;<br><span class="hljs-keyword">delete</span> pf;<br></code></pre></td></tr></table></figure><ul><li>new内含两阶段操作</li></ul><ol><li>调用<code>::operator new</code>配置内存</li><li>调用<code>Foo::Foo()</code>构造对象</li></ol><ul><li>delete也包含两阶段操作</li></ul><ol><li>调用<code>Foo::~Foo()</code>将对象析构</li><li>调用<code>::operator delete</code>释放内存</li></ol><ul><li>STL_allocator决定将这两阶段操作区分开来。</li></ul><ol><li>内存配置操作由alloc::allocate()负责，内存释放操作由alloc::deallocate()负责</li><li>对象构造由::construct()负责，对象析构由::destroy()负责</li></ol><h3 id="构造和析构基本工具：construct-和destroy"><a href="#构造和析构基本工具：construct-和destroy" class="headerlink" title="构造和析构基本工具：construct()和destroy()"></a>构造和析构基本工具：construct()和destroy()</h3><ul><li>construct()接受一个指针p和一个初值value，该函数将初值设定到指针所指空间上，C++的replacement new可用来完成这一任务</li><li>destroy()有两个版本</li></ul><ol><li>接受一个指针。直接调用该对象的析构函数即可</li><li>接受first和last两个迭代器，将[first, last)范围内的对象析构掉</li></ol><p>为了防止范围很大且每个对象的析构函数都是trivial(无关紧要的) destructor，进行以下操作：</p><ol><li>利用value_type()获得迭代器所指对象的类型</li><li>利用<code>__type_traits&lt;T&gt;</code>判断该类的析构函数是否为trivial。若是<br>(<strong>true_type)，则什么都不做；若否(</strong>false_type)，以循环方式遍历整个范围，且每经历一个对象调用一次destroy()</li></ol><h3 id="空间的分配和释放，std-alloc"><a href="#空间的分配和释放，std-alloc" class="headerlink" title="空间的分配和释放，std::alloc"></a>空间的分配和释放，std::alloc</h3><p>SGI的设计方法：</p><ul><li>向system heap请求空间</li><li>考虑多线程状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多小型区块可能造成的内存碎片问题</li></ul><p>源代码层面：</p><ul><li>以<code>::operator new()</code>和<code>::operator delete()</code>完成内存的分配和释放</li></ul><p>针对小型区块可能造成的内存破碎问题，采用双层配置器。</p><ul><li>第一级配置器使用<code>malloc()</code>和<code>free()</code></li><li>第二级配置器视情况采用不同的策略：<ul><li>当配置区块超过128byte时，视为“足够大”，调用第一级配置器</li><li>当配置区块小于128byte时，视为“过小”，为了降低额外负担(overhead)，使用复杂的memory pool整理方式</li></ul></li></ul><h3 id="第一级配置器-malloc-alloc-template"><a href="#第一级配置器-malloc-alloc-template" class="headerlink" title="第一级配置器 __malloc_alloc_template"></a>第一级配置器 __malloc_alloc_template</h3><ul><li>一级配置器以malloc(), free(), realloc()等C函数执行实际的内存分配、释放、重分配操作，并实现出类似C++ new-handler的机制</li><li>所谓C++ new-handler机制是，它可以要求系统在内存分配需求无法满足时，调用一个你所指定的函数，即一旦::operator new无法完成任务，在丢出std::bad_alloc异常状态之前，会先调用由客户端指定的处理例程，该处理例程被称为new-handler</li></ul><h3 id="第二级配置器-default-alloc-template"><a href="#第二级配置器-default-alloc-template" class="headerlink" title="第二级配置器 __default_alloc_template"></a>第二级配置器 __default_alloc_template</h3><ul><li>第二级配置避免太多小额区块造成的内存碎片</li><li>小额区块带来的不仅是内存碎片，配置时的额外负担也是一个问题</li><li>当区块小于128 byte时，以内存池管理：维护一系列大小为8 byte倍数的free-list</li></ul><h3 id="空间配置函数allocate"><a href="#空间配置函数allocate" class="headerlink" title="空间配置函数allocate()"></a>空间配置函数allocate()</h3><ul><li>__default_alloc_template的标准接口函数</li><li>先判断区块大小<ul><li>大于128 bytes就调用第一级配置器</li><li>小于128 bytes就检查对应free list，若有可用区块，直接拿来用；诺没有，则将区块大小上调至8倍数边界，然后调用refill()，准备为free list重新填充空间</li></ul></li></ul><h3 id="空间释放函数deallocate"><a href="#空间释放函数deallocate" class="headerlink" title="空间释放函数deallocate()"></a>空间释放函数deallocate()</h3><ul><li>判断区块大小<ul><li>大于128 bytes调用第一级配置器</li><li>小于128 bytes找出对应free list，将区块回收</li></ul></li></ul><h3 id="重新填充free-lists"><a href="#重新填充free-lists" class="headerlink" title="重新填充free lists"></a>重新填充free lists</h3><ul><li>从内存池取空间为free lsits重新填充空间</li></ul><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>分为多种情况</p><ul><li>内存充足：则调出20个区块返回给free list</li><li>内存不足以提供20个区块，但还足以供应一个以上的区块，拨出不足20个区块的空间出去，nobjs参数修改为实际能提供的区块数</li><li>一个区块都无法供应，则使用malloc()中分配内存</li><li>若system heap的空间不足，则利用out-of-memory处理机制（类似new-handler机制），释放其他内存来使用</li><li>否则抛出bad_alloc异常</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
